//***************************************************************************
//                          pvapp.h  -  description
//                             -------------------
//  begin            : dom jun 21 20:38:58 2020
//  generated by     : pvdevelop (C) Lehrig Software Engineering
//  email            : lehrig@t-online.de
//***************************************************************************
#ifndef _PVAPP_H_
#define _PVAPP_H_

#ifdef USE_INETD
static int trace=0; // todo: set trace=0 if you do not want printf() within event loop
#else
static int trace=1; // todo: set trace=0 if you do not want printf() within event loop
#endif

#include "processviewserver.h"
// todo: comment me out
#include "rlmodbusclient.h"
//#include "rlsiemenstcpclient.h"
//#include "rlppiclient.h"
#include "modbusdaemon.h"             // this is generated. Change for name.h -> "name.mkmodbus"
//#include "siemensdaemon.h"            // this is generated
//#include "ppidaemon.h"                // this is generated

int show_mask1(PARAM *p);


//***************************************************************************
// Meu código
// Comum para Main e Masks

#include "stdlib.h"
#include "math.h"
#include "rlthread.h"
#define BG_COLOR 239,235,231

typedef struct
{
  float SIN;
  float TRI;
  float SQR;
  int OSC;
  float x;
  int i;
} TAGS;

extern rlModbusClient modbus;

int Ton(int IN, int PT, int *Q);
int Toff(int IN, int PT, int *Q);
int Ftrig(int IN, int *Q);
int Rtrig(int IN, int *Q);
long blkInt(long I, int Ctrl);
short DI_I(long I);
short Integrator(short I, char SET, short VAL, short *Q);
long DIntegrator(long I, char SET, long VAL, long *Q);
int PT1(long I, long T, long *Q);
int P(long I, int Vp, char SET, int VAL);
int PI(long I, int Vp, int TA, char SET, int VAL, long *INT, long *Q);
int PID(long I, int Vp, int Vhf, int TA, int TB, char SET, int VAL, long *INT, long *INT1, long *Q);
int LAG(long I, int V0, int Vp, int TA, char SET, int VAL, long *INT, long *Q);
int LEADLAG(long I, int V0, int Vp, int Vhf, int TA, int TB, char SET, int VAL, long *INT, long *INT1, long *Q);
int WashOut(long I, long T, long *INT, int *Q);
char *describeArc(char *buf, float x, float y, float radius, float startAngle, float endAngle);

/////////////////////////////////////////////
#ifndef _MAIN_  // Código exclusivo das Masks
/////////////////////////////////////////////

extern TAGS tag;

/////////////////////////////////////////////////////////////////
#else // Aqui começa o código que vai ser compilado na seção Main
/////////////////////////////////////////////////////////////////

rlThread usrThread;
rlMutex mutex;
TAGS tag;

static void task01()
{
 static int i = 0;
 static int SQR = 0;
 static int TRI = 0;
 static float Pi = 0;
 if (!Pi) Pi = acos(-1.0);

 printf("Task01 : %d\n",i);
 tag.i = i;

 tag.SIN = 100*sin(i*Pi/40);

 if(!(i%10)) SQR = !SQR;
 tag.SQR = (SQR * 2 - 1)*100; 

 if(SQR) tag.TRI = ((TRI++)/10.0-0.5) * 200;
 else    tag.TRI = ((TRI--)/10.0-0.5) * 200;
 //printf("SIN : %f\tSQR : %f\tTRI : %f\n",tag.SIN,tag.SQR,tag.TRI);

 int slave=1, adr=0;
 modbus.writeSingleCoil(slave,adr,tag.OSC);
 modbus.writePresetSingleRegister(slave,adr++,(unsigned short)tag.SIN);
 modbus.writePresetSingleRegister(slave,adr++,(unsigned short)tag.SQR);
 modbus.writePresetSingleRegister(slave,adr++,(unsigned short)tag.TRI);
 i++;
};

static void task02()
{
 static int i = 0;
 printf("\tTask02: %d\n",i);
 i++;
};

static void setup()
{
  int i;
  i=system("if ! pgrep -c modbusdaemon; then xterm -T ModbusDaemon -e ./modbusdaemon; fi &");
  i=system("if ! pgrep -c pvbrowser; then pvbrowser localhost:5051; fi &");
// https://www.modbusdriver.com/diagslave.html
// https://github.com/sourceperl/mbtget
  i=system("if ! pgrep -c diagslave; then xterm -T DiagSlave -e diagslave -p 5502; fi &");
  i=system("if ! pgrep -c mbtget; then xterm -T MBTGET -e bash -c \" \
            while true; do clear; \
                       echo HOLDING REGISTERS; \
                       mbtget -p 5502 -2c -r3 -a 0 -n 5; \
                       echo; echo COILS; \
                       mbtget -p 5502 -r1 -a 0 -n 5; \
                       sleep 1; \
            done\" & fi");
  i=i;
};


#define TZ 100

static void loop()
{
 static int i=0;
 static int T1=0, T2=0, Osc=0 ;

 Osc=Toff(Ton(!Osc,2000/TZ,&T1),2000/TZ,&T2); // Oscilador com timers. Período 4 s
 tag.OSC=Osc;

 if(!(i%10)) task01(); // Chamar task01 a cada 1 segundo
 if(!(i%30)) task02(); // Chamar task02 a cada 3 segundos

 i++;
 pvSleep(TZ);
};

static void *usrMain(void *arg)
{
 setup();
 while(1) loop();
 return arg;
};


//***************************************************************************
// minhas funções auxiliares

int Ton(int IN, int PT, int *Q) 
{
  if (*Q) (*Q)--;
  if (!IN) *Q=PT;
  return !*Q;
}

int Toff(int IN, int PT, int *Q)
{
  if (*Q) (*Q)--;
  if (IN) *Q=PT;
  return !!*Q;
}

int Ftrig(int IN, int *Q)
{
 int i=*Q;
 IN=!!IN; // qualquer valor diferente de zero se transforma em 1
 *Q=IN;
 return IN && (IN != i);
}

int Rtrig(int IN, int *Q)
{
 int i=*Q;
 IN=!!IN; // qualquer valor diferente de zero se transforma em 1
 *Q=IN;
 return !IN && (IN != i);
}

long blkInt(long I, int Ctrl)
{
  return ((I>0) && (Ctrl>=32767)) || ((I<0) && (Ctrl<=-32767)) ? 0 : I; 
}
 
short DI_I(long I)
{
 if(I> 32767) return 32767;
 if(I<-32767) return -32767;
 return (short) I;
} 

short Integrator(short I, char SET, short VAL, short *Q)
{
 if(!SET)
 {
     if (!I)
     {
         long Q0 = *Q + I;
         if (I < 0)
             if (Q0 < *Q) *Q = Q0;
             else *Q = -32767;
         else
             if (Q0 > *Q) *Q = Q0;
             else *Q = 32767;
     }
 }
 else *Q = VAL;
 
 return *Q;
}

long DIntegrator(long I, char SET, long VAL, long *Q)
{
 if(!SET)
 {
     if (!I)
     {
         long Q0 = *Q + I;
         if (I < 0)
             if (Q0 < *Q) *Q = Q0;
             else *Q = -2147483647;
         else
             if (Q0 > *Q) *Q = Q0;
             else *Q = 2147483647;
     }
 }
 else *Q = VAL;
 
 return *Q;
}

int PT1(long I, long T, long *Q)
{
 *Q = DIntegrator((I-*Q),0,0,Q)/T;
 return DI_I(*Q);
}

int P(long I, int Vp, char SET, int VAL)
{
 long Q = SET ? VAL : I * Vp / 100;
 return DI_I(Q);
}

int PI(long I, int Vp, int TA, char SET, int VAL, long *INT, long *Q)
{
 long I1 = 0;
 if (TA)
 {
     long Ib = blkInt(I,*Q);
     VAL = (VAL * 100 / Vp - I) * TA;
     I1 = DIntegrator(Ib, SET, VAL, INT) / TA;
 }
 *Q = P((I + I1), Vp, SET, VAL);
 return DI_I(*Q);
}

int PID(long I, int Vp, int Vhf, int TA, int TB, char SET, int VAL, long *INT, long *INT1, long *Q)
{
 long D = 0;
 if(Vhf!=0 && TB!=0)
 {
     long REL = Vhf * 100 / Vp; 
     int TB1 = REL * 12 / 1000;
     TB = (TB > TB1) ? TB : TB1;
     D = I - *INT1;
     DIntegrator( (D * REL / 100 / TB)  , SET, I, INT1);
     D *= Vhf / 100;
 }
 *Q = D + PI(I, Vp, TA, SET, VAL-D, INT, Q);
 return DI_I(*Q);
}

int LAG(long I, int V0, int Vp, int TA, char SET, int VAL, long *INT, long *Q)
{
 long I1 = 0;
 if (TA)
 {
     long Ib = blkInt(I - *Q * 100 / V0,*Q);
     VAL = (VAL * 100 / Vp - I) * TA;
     I1 = DIntegrator(Ib, SET, VAL, INT) / TA;
 }
 *Q = P((I + I1), Vp, SET, VAL);
 return DI_I(*Q);
}

int LEADLAG(long I, int V0, int Vp, int Vhf, int TA, int TB, char SET, int VAL, long *INT, long *INT1, long *Q)
{
 long D = I;
 if(Vhf!=0 && TB!=0)
 {
     long REL = Vhf * 100 / Vp; 
     int TB1 = REL * 12 / 1000;
     TB = (TB > TB1) ? TB : TB1;
     long X = I * REL / 100;
     D = I - (*INT1 + X);
     DIntegrator( (D * REL / 100 / TB)  , SET, (I - X), INT1);
     D = *INT1 + X;
 }
 *Q = LAG(D, V0, Vp, TA, SET, VAL, INT, Q);
 return DI_I(*Q);
}

int WashOut(long I, long T, long *INT, int *Q)
{
 *Q = I - DIntegrator( *Q, 0, 0, INT) / T;
 return DI_I(*Q);
}


typedef struct
{
 float x,y;
} cartesian;


void polarToCartesian(float centerX, float centerY, float radius, float angleInDegrees, cartesian *p) 
{
  float angleInRadians = angleInDegrees * acos(-1) / 180.0;
  p->x = centerX + radius * cos(angleInRadians);
  p->y = centerY + radius * sin(angleInRadians);
}

char *describeArc(char *buf, float x, float y, float radius, float startAngle, float endAngle)
{
    cartesian start, end;

    polarToCartesian(x, y, radius, startAngle, &start);
    polarToCartesian(x, y, radius, endAngle, &end);

    int arcSweep = (endAngle - startAngle <= 180);
       
    sprintf(buf,"M %g,%g A %g,%g 0 0 %d %g,%g", start.x, start.y, radius, radius, arcSweep, end.x, end.y);
    return buf;       
}


#endif

// meu código termina aqui
//***************************************************************************

#endif
